#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass uwmthesis
\begin_preamble
\date{2016}
\title{Opracowanie automatycznego systemu chłodzącego stacji roboczej z wykorzystaniem Arduino}
\author{Michał Bartosz Ludwikowski}
\etitle{Developing automatic cooling system for workstation using Arduino}
\wykonanaw{katedrze Matematycznych Metod Informatyki}
\ewykonanaw{the Department of Mathematical Methods of Informatics}
\podkierunkiem{dra Krzysztofa Sopyły}
\epodkierunkiem{dr Krzysztof Sopyła}
\usepackage{url}
\end_preamble
\options wmii,inf,inz
\use_default_options true
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\begin_layout Plain Layout


\backslash
tableofcontents
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Streszczenie
\end_layout

\begin_layout Standard
Moc obliczeniowa komputerów znacznie wzrosła na przestrzeni ostatnich lat.
 Wraz ze wzrostem mocy obliczeniowej wzrosła również ilość ciepła generowana
 przez podzespoły komputera.
 Jest to oczywiście zjawisko niekorzystne i niepożądane.
 Jak wiadomo urządzenia elektroniczne pod wpływem ciepła przestają pracować
 prawidłowo, a nadmierne ich nagrzanie może doprowadzić do całkowitego ich
 uszkodzenia.
\end_layout

\begin_layout Standard
Komputery stacjonarne chłodzone są najczęściej powietrzem.
 Wykorzystuje się do tego radiatory i wentylatory.
 Ostatnimi czasy pojawiły się rozwiązania wykorzystujące ciecz do transportowani
a ciepła, które działają lepiej niż rozwiązania bazujące na chłodzeniu powietrze
m.
 lecz te rozwiązania odprowadzają ciepło tylko z punktów, do których przyczepion
e są elementy układu chłodzącego, przez co nie zabezpieczają kompleksowo
 podzespołów komputera.
 
\end_layout

\begin_layout Standard
Poniższa praca stara się rozwiązać problem poprzez zaprojektowanie oraz
 wykonanie automatycznego systemu chłodzącego, który odprowadza ciepło z
 całej powierzchni elektroniki poprzez zanurzenie jej w cieczy, która nie
 przewodzi prądu.
\end_layout

\begin_layout Standard
Stworzone rozwiązanie wykorzystujące platformę Arduino, układ chłodzący
 oraz algorytm sterujący pozwala na skuteczne odprowadzanie ciepła z podzespołów
 komputera o czym świadczą przeprowadzone eksperymenty, co może pozwolić
 na zwiększenie wydajności podzespołów komputera.
\end_layout

\begin_layout Chapter*
Abstract
\end_layout

\begin_layout Standard
Computing power of machines has increased significantly in recent years.
 With the increase in computing power has also increased the amount of heat
 generated by the computer's components.
 This is obviously disadvantageous and undesirable phenomenon.
 As it is known, electronic devices stop working properly due to high temperatur
es, and excessive overheating can result in complete breakage.
\end_layout

\begin_layout Standard
Desktop PC’s are usually cooled by air.
 They use heat sinks and fans to cool inner components.
 Recently solutions based on the fluid for transporting heat appeared, which
 works better than solutions based on air cooling which only dissipate the
 heat from the points where cooling system components are mounted, and cannot
 completely protect the system components.
\end_layout

\begin_layout Standard
The following work presents how to solve the problem by designing and creation
 of an automatic cooling system which removes heat from the entire surface
 of electronics by immersing it in a liquid that does not conduct electricity.
 
\end_layout

\begin_layout Standard
Solution was created using the Arduino platform, cooling system and control
 algorithm allows efficient heat dissipation from the computers components,
 as evidenced in performed experiments, which may increase efficiency of
 computer components
\end_layout

\begin_layout Chapter
Wstęp
\end_layout

\begin_layout Section
Wprowadzenie
\end_layout

\begin_layout Standard
Podzespoły obecnych komputerów z racji dążenia do coraz większej mocy obliczenio
wej stacji roboczych generują duże ilości ciepła.
 Do elementów stacji roboczej, które generują to ciepło można zaliczyć:
 procesor, kartę graficzną, zasilacz, pamięć operacyjną oraz elementy płyty
 głównej takie jak sekcja zasilania procesora czy mostek północny.
 
\end_layout

\begin_layout Standard
Chłodzenie podzespołów komputera to bardzo istotny aspekt poprawnej pracy
 stacji roboczej.
 W dzisiejszych czasach najpopularniejszym sposobem chłodzenia są zaawansowane
 radiatory chłodzone powietrzem aktywnie (zastosowanie wentylatora) lub
 pasywnie (brak wentylatora).
 Coraz popularniejsze stają się bloki wodne, które zastępując radiatory
 umożliwiają wymianę ciepła podzespołu z cieczą.
 Sposób ten pozwala jedynie na przekazanie ciepła z ograniczonych powierzchni
 elementów, z których zbudowane są podzespoły komputera.
 Rozwiązaniem, które pozwoli zwiększyć te powierzchnie jest zanurzenie całego
 komputera w chłodziwie.
\end_layout

\begin_layout Section
Cel pracy
\end_layout

\begin_layout Standard
Niniejsza praca ma na celu zaprojektowanie oraz wykonanie automatycznego
 systemu chłodzącego stację roboczą (Rysunek 1.1).
 W pracy poza opisami narzędzi takich jak Arduino wykorzystanych do realizacji
 projektu znajdziemy bogato ilustrowane opisy poszczególnych kroków dążących
 do stworzenia skutecznego systemu chłodzącego.
 Skuteczność systemu omówiona i podsumowana zostanie na wykresach temperatur
 podzespołów zebranych podczas wzmożonej pracy stacji roboczej.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/WP_20160109_13_21_57_Pro.jpg
	lyxscale 50
	width 80text%
	groupId fotografie

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gotowy projekt
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Układ pracy
\end_layout

\begin_layout Standard
Praca została podzielona na pięć rozdziałów.
 Kolejne rozdziały to wstęp, opis użytych technologii, sprawozdanie z wykonania
 projektu, testy skuteczności systemu chłodzącego oraz podsumowanie.
\end_layout

\begin_layout Standard
W drugim rozdziale opisane zostały technologie, przy pomocy których wykonano
 poniższy projekt.
 Umieszczono tam opis platformy Arduino, programów wykorzystywanych przy
 projektowaniu układów elektronicznych, projektowania wspomaganego komputerowo
 oraz programów wykorzystywanych podczas testowania skuteczności systemu
 chłodzącego.
\end_layout

\begin_layout Standard
Rozdział trzeci jest sprawozdaniem z procesu projektowania oraz wykonania
 poszczególnych elementów układu chłodzącego.
 Rozdział ten podzielony został na trzy sekcje dotyczące: 
\end_layout

\begin_layout Itemize
układu elektronicznego, który współpracuje z Arduino,
\end_layout

\begin_layout Itemize
algorytmu sterownika,
\end_layout

\begin_layout Itemize
układu chłodzącego.
\end_layout

\begin_layout Standard
Testy skuteczności zbudowanego układu zawarte zostały w rozdziale czwartym.
 Przedstawiono tutaj wykresy pomiaru temperatur rdzeni procesora komputera
 i porównano je z danymi zebranymi przed wykonaniem systemu.
\end_layout

\begin_layout Standard
Ostatni rozdział jest podsumowaniem całego projektu.
 Przedstawiono tu ogólną ocenę zbudowanego systemu oraz uwagi, dotyczące
 zastosowanych rozwiązań.
\end_layout

\begin_layout Chapter
Opis technologii wykorzystanych podczas realizacji projektu
\end_layout

\begin_layout Section
Arduino
\end_layout

\begin_layout Standard
Arduino
\begin_inset CommandInset citation
LatexCommand cite
key "arduino:intro"

\end_inset

 jest platformą prototypową typu open source, opartą na łatwym w użyciu
 hardware oraz software.
 Płytki Arduino (Rysunek 2.1) są w stanie odczytywać dane różnego pochodzenia
 - światło padające na sensor, przyciśnięty przycisk, dane z sieci - i przekszta
łcać je w żądane sygnały wyjścia - zapalenie diod LED, opublikowanie czegoś
 w sieci czy załączenie silnika.
\end_layout

\begin_layout Standard
Sama płytka Arduino jest mikrokontrolerem zamontowanym wraz z obsługą wejść/wyjś
ć na pojedynczym układzie drukowanym.
 Na urządzeniu znajdziemy kontroler, wygodne w użyciu, cyfrowe i analogowe
 linie wejścia/wyjścia, interfejs UART lub USB do komunikacji z komputerem.
\end_layout

\begin_layout Standard
Celem projektu Arduino jest dostarczenie szerokiemu gronu ludzi narzędzi
 wykorzystywanych do tworzenia własnych interaktywnych projektów wymagających
 sterowania bądź przetwarzania odbieranych sygnałów.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/płytkaUno.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Arduino UNO
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
Źródło: http://blog.khron.net/wp-content/uploads/2014/05/ArduinoUno_R3_Front.jpg
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Język programowania Arduino
\end_layout

\begin_layout Standard
Platforma Ardino posiada własny język programowania Arduino, który bazuje
 na Wiring oraz językach C/C++.
\end_layout

\begin_layout Standard
Wiring
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:wiring"

\end_inset

 jest framework'iem na licencji typu open-source złożonym z języka programowania
, zintegrowanego środowiska deweloperskiego oraz mikrokontrolera wbudowanego
 w jedą płytę (jak w przypadku Arduino).
 Wiring oparty został o projekt Processing, który jest językiem i zintegrowanym
 środowiskiem stworzonym na MIT (ang.
 Massachusetts Institute of Technology) Media Lab.
 Projekt Wiring rozpoczął się w 2003 roku w Instytucie Wzornictwa Interakcji
 Ivrea.
 Obecnie rozwijany w Szkole Architektury i Projektowania na Uniwersytecie
 Los Andes w Kolumbii.
 Wynalazcą platformy jest Hernando Barragán.
 Środowisko Wiring IDE zostało napisane w języku JAVA.
 Zaprojektowano je by wprowadzać elektroników, hobbystów i artystów do programow
ania elektroniki.
\end_layout

\begin_layout Subsection
Arduino Software (IDE)
\end_layout

\begin_layout Standard
Wgrywanie projektów na płytkę Arduino odbywa się za pośrednictwem Arduino
 IDE (ang.
 Integrated Development Environment).
 Jest to środowisko zawierające (Rysunek 2.2): 
\end_layout

\begin_layout Itemize
edytor tekstu posiadający funkcje jak podświetlanie składni, przeszukiwanie
 kodu i zamienianie czy automatyczne utrzymywanie wcięć,
\end_layout

\begin_layout Itemize
pole komunikatów zwracające wyniki działania Arduino Software IDE np.
 rezultat zapisywania czy eksportu oraz informujące o błędach, które wystąpiły,
\end_layout

\begin_layout Itemize
konsolę wyświetlającą wyjście Arduino Software oraz błędy występujące w
 kodzie,
\end_layout

\begin_layout Itemize
szeregowy monitor wyświetlający dane odebrane z płytki Arduino oraz umożliwiając
y wysyłanie danych do płytki.
\end_layout

\begin_layout Standard
Pliki będące wynikiem pracy w Arduino Software IDE nazywane są skeczami
 i posiadają rozszerzenie .ino.
 Arduino Software zbudowane jest na podstawie projektu Processing.
\end_layout

\begin_layout Standard
Processing
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:processing"

\end_inset

 jest językiem programowania oraz zintegrowanym środowiskiem programistycznym
 (ang.
 IDE) stworzonym przez Ben'a Fry i Casey'a Reas.
 Powstał w MediaLab działającym w MIT (ang.
 Massachusetts Institute of Technology).
 Prace nad nim rozpoczęły się w roku 2001, na potrzeby sztuki elektronicznej
 oraz projektowania graficznego.
 Język bazuje na języku Java, jednak ma uproszczoną składnię i graficzny
 model programowania.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/ardideSCRE.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Arduino IDE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Narzędzia do projektowania elektroniki
\end_layout

\begin_layout Standard
Projektowanie układów elektronicznych to złożony proces.
 Jednym elementem tego procesu są schematy połączeń poszczególnych elementów
 oraz projekty płytek PCB (z ang.
 Printed Circuit Board).
 Proces tworzenia tych schematów i projektów można ułatwić poprzez stosowanie
 odpowiedniego oprogramowania.
\end_layout

\begin_layout Subsection
Eagle
\end_layout

\begin_layout Standard
EAGLE
\begin_inset CommandInset citation
LatexCommand cite
key "eagle"

\end_inset

 (z ang.
 Easy Applicable Graphical Layout Editor) jest wszechstronnym oprogramowaniem
 do tworzenia projektów PCB.
 EAGLE wykorzystywany jest przez profesjonalistów pracujących dla światowych
 koncernów elektronicznych, hobbystów oraz studentów.
\end_layout

\begin_layout Standard
Oprogramowanie składa się z trzech modułów z identycznym interfejsem użytkownika
 (Rysunek 2.3):
\end_layout

\begin_layout Itemize
edytor schematów - umożliwia tworzenie symbolicznych, czytelnych schematów,
 które wzbogacą dokumentację projektu,
\end_layout

\begin_layout Itemize
edytor układu elektronicznego - przy pomocy tego modułu zaprojektujemy układ
 gotowy do wydrukowania,
\end_layout

\begin_layout Itemize
autorouter - moduł automatycznego tworzenia ścieżek elektrycznych na projektowan
ym układzie elektronicznym.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/eagleSCRE.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Program EAGLE - wszystkie okna
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Fritzing
\end_layout

\begin_layout Standard
Fritzing to narzędzie służące do tworzenia schematów oraz rysunków poglądowych
 projektów elektronicznych.
 Fritzing jest narzędziem open source.
 Narzędzie to pozwala na tworzenie czytelnych profesjonalnych schematów,
 jednak to co wyróżnia to narzędzie to schematy poglądowe (Rysunek 2.4),
 które pokazują nam faktyczny wygląd skomponowanego układu.
 
\end_layout

\begin_layout Standard
Bogata biblioteka części różnych producentów (w tym Arduino), ciągle rośnie
 ze względu na możliwość dodawania własnych części i dzieleniem się nimi
 z innymi użytkownikami Fritzing.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/fritzSCRE.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Program Fritzing - edytor schematów poglądowych
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
CAD
\end_layout

\begin_layout Standard
Komputery i oprogramowanie od wielu lat znajdują zastosowanie w różnych
 dziedzinach naszego życia.
 CAD (ang.
 computer aided design) jest wykorzystaniem systemów komputerowych do wspomagani
a tworzenia, modyfikacji, analizy lub optymalizacji projektu.
 Znajduje zastosowanie w takich dziedzinach jak: inżynieria mechaniczna,
 inżynieria elektryczna czy inżynieria budowlana.
\end_layout

\begin_layout Subsection
AutoCAD
\end_layout

\begin_layout Standard
Program
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:autoCAD"

\end_inset

 umożliwiający projektowanie wspomagane komputerowo.
 Program stworzony został przez firmę Autodesk, a jego pierwsza wersja zaprezent
owana została na targach COMDEX w Las Vegas w listopadzie 1982 roku, sprzedaż
 produktu ruszyła miesiąc później.
 Program jest nadal rozwijany i jego najnowsza wersja nosi nazwę AutoCAD
 2016.
 AutoCAD umożliwia wspomaganie projektowania 2D, 3D oraz dzięki specjalnym
 dodatkom 2.5D.
 Pierwotnie wykorzystywany był tylko przez mechaników, jednak dzięki rozszerzeni
u programu przez wiele nakładek mp.
 AutoCAD Electrical, AtuoCAD Mechanical, Architectural Desktop, Civil Design
 itp.
 stał się platformą wykorzystywaną przez architektów i projektantów różnych
 dziedzin inżynierii.
\end_layout

\begin_layout Section
Narzędzia do testów wydajności
\end_layout

\begin_layout Standard
Podzespoły komputera nagrzewają się podczas intensywnej pracy.
 Aby sprawdzić skuteczność zbudowanego systemu chłodzącego konieczne będzie
 obciążenie stacji roboczej.
 W celu przeprowadzenia testów wykorzystamy oprogramowanie, które umożliwia
 obciążenie komputera oraz monitorowanie temperatury.
\end_layout

\begin_layout Subsection
OCCT
\end_layout

\begin_layout Standard
OCCT
\begin_inset CommandInset citation
LatexCommand cite
key "occt"

\end_inset

 (ang.
 OverClock Checking Tool) jest programem służącym do sprawdzania stabilności
 pracy stacji roboczej.
 Poza stabilnością sprawdzimy także temperatury osiągane przez poszczególne
 podzespoły czy napięcie występujące na tych podzespołach.
 Poza wymienionymi danymi program dostarcza również informacje o posiadanym
 procesorze czy karcie graficznej.
 Program podczas działania bardzo mocno obciąża komputer (wykorzystanie
 procesora ~98 - 100%), jednocześnie dając możliwość stałego kontrolowania
 wyżej wymienionych danych.
 W programie dostępne są cztery testy: autorski, test na bazie biblioteki
 LINPACK stworzonej przez Intel, test sprawdzający kartę graficzną pod względem
 renderowania obiektów 3D oraz test zasilacza.
 Wyniki przeprowadzonych testów obrazowane są na wykresach zapisanych na
 dysku w postaci plików .png.
\end_layout

\begin_layout Chapter
Realizacja projektu systemu chłodzącego
\end_layout

\begin_layout Section
Projekt techniczny
\end_layout

\begin_layout Standard
System chłodzący jest połączeniem sterownika na bazie Arduino z podzespołami
 wykonawczymi oraz zamknięcie tego w szczelnej obudowie.
\end_layout

\begin_layout Subsection
Projekt systemu chłodzącego
\end_layout

\begin_layout Standard
Głównym celem projektu jest zanurzenie podzespołów w cieczy, jednak nie
 każda ciecz może być użyta w tym projekcie.
 Główną cechą zastosowanej cieczy musi być jej przewodnictwo elektryczne,
 a właściwie jego zupełny brak.
 Woda destylowana nie przewodzi prądu, jednak jest bardzo uniwersalnym rozpuszcz
alnikiem co prowadzi do zmiany tej cechy.
 Cieczą zastosowaną w projekcie jest parafina ciekła C10 - C13.
 Nie przewodzi ona prądu oraz ma ciepło właściwe mniejsze o połowę od ciepła
 właściwego wody.
 Skutkuje to mniejszą ilością energii potrzebnej do ogrzania zadanej ilości
 masy danego ciała o zadaną ilość stopni.
 Oznacza to, że parafina szybciej odbierze temperaturę z radiatora.
\end_layout

\begin_layout Standard
Projekt zakłada umieszczenie podzespołów stacji roboczej w cieczy, jednak
 nie wszystkie zostaną umieszczone wewnątrz pojemnika.
 Dyski twarde HDD, pomimo hermetycznego zamknięcia talerzy, posiadają zawory
 wyrównujące ciśnienie wewnątrz obudowy dysku.
 Zawory te mogły by nie wytrzymać kontaktu z cieczą, co doprowadziło by
 do ich zniszczenia.
 Zasilacz, ze względu na swoje rozmiary również został umieszczony poza
 pojemnikiem.
 Ciecz chłodząca podzespoły kumputera oddawać ciepło będzie w chłodnicy
 umieszczonej obok pojemnika.
 
\end_layout

\begin_layout Standard
Plan rozmieszczenia poszczególnych elementów, oraz planowanych połączeń
 przedstawiono na rysunku poglądowym (Rysunek 3.1).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/rysunekPogl.PNG
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat poglądowy układu chłodzenia wykonany w AutoCAD 2016
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wykonanie systemu chłodzącego
\end_layout

\begin_layout Standard
Jednym z ważniejszych elementów tego projektu jest pojemnik, w którym zanurzony
 zostanie komputer.
 Z materiałów dostępnych na runku wybrano szkło.
 W porównaniu do innych materiałów, np.
 szkła akrylowego (popularnie nazywanego 
\begin_inset Quotes pld
\end_inset

plexi
\begin_inset Quotes prd
\end_inset

), szkło jest tańsze oraz nie rysuje się.
 Wykonanie specjalnego pojemnika zlecono zewnętrznej firmie.
 Pojemnik jest prostopadłościennym naczyniem z otworami w prawej ściance.
 Rama z zamontowanymi podzespołami opierać się będzie na krawędziach naczynia
 w związku z czym wybrano szkło o grubości 5mm.
 Projekt wraz z wymiarami przedstawiono na rzucie izometrycznym (Rysunek
 3.2).
 Projekt został przesłany do firmy wykonującej akwarium.
 Wymiary wyrażone są w milimetrach i są to wymiary wewnętrzne akwarium.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/wymiar.PNG
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Rzut izometryczny bryły pojemnika wraz z wymiarami wykonany w AutoCAD 2016
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podzespoły komputera potrzebują sztywnej ramy, do której zostaną przymocowane.
 W tym projekcie postanowiono wykorzystać elementy dotychczasowej obudowy
 komputera.
 Tak jak w zwykłej obudowie głównym elementem ramy utrzymującej będzie tacka
 z nawierconymi otworami pod kołki dystansowe.
 Tył obudowy wraz z panelem maskującym wykorzystany został do stworzenia
 pokrywy akwarium oraz wykorzystany został jako element utrzymujący podzespoły
 w pojemniku.
 Poniżej przedstawiono elementy wykorzystane przy tworzeniu ramy podzespołów
 (Rysunek 3.3)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/WP_20151107_13_44_25_Pro.jpg
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Elementy obudowy wykorzystane w projekcie
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tacka, na której zamontowana jest płyta główna została przycięta do rozmiarów
 pasujących do pojemnika, w którym zostaną umieszczone podzespoły komputera.
 Wycięta tylna część obudowy wraz z maskownicą płyty głównej obudowy została
 wydłużona i wyposażona w uchwyty zapobiegające się przemieszczaniu całej
 ramy po akwarium.
 Po złączeniu elementów ramy i przykręceniu do nich podzespołów komputera
 zajęto się poprowadzeniem przewodów.
 Przewody zostały umieszczone tak by nie zaklinować któregoś z wiatraków
 znajdujących się w pojemniku oraz by całość wyglądała estetycznie (Rysunek
 3.4).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/WP_20151130_18_41_41_Pro.jpg
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Rama z zamontowanymi podzespołami komputera
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Następnym etapem było przygotowanie akwarium wraz z pompą i chłodnicą.
 W otworach w ściance akwarium umieszczono reduktory mosiężne z uszczelniającymi
 o ringami, na gwinty reduktorów nakręcono mosiężne kolanka z wyprowadzeniem
 na podłączenie węża.
 Gwinty uszczelniono silikonem silnikowym.
 Gumowe węże przymocowano do kolanek, a następnie przymocowano do chłodnicy.
 Do projektu wykorzystano chłodnicę układu klimatyzacji z Volkswagena Passat
 B5.
 W reduktorze umieszczonym w dolnym otworze zamocowano pompę.
 Zastosowana pompa to pompa paliwa z Fiata Punto (Rysunek 3.5).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/WP_20151202_21_50_36_Pro.jpg
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Zmontowane akwarium z chłodnicą i pompą
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kolejnym etapem było umieszczenie ramy z podzespołami komputera w wypełnionym
 pojemniku, odpowietrzenie chłodnicy oraz zaprojektowanie wykonanie układu
 elektronicznego odpowiedzialnego za sterowanie tworzonym projektem.
 
\end_layout

\begin_layout Section
Elektroniczny układ współpracujący z Arduino
\end_layout

\begin_layout Standard
Platforma Arduino została stworzona w celu popularyzacji tworzenia interaktywnyc
h projektów elektronicznych oraz układów automatyzacji.
 Płytka Arduino zapewnia wyprowadzenie pinów komunikacyjnych mikrokontrolera.
 Zadaniem osoby budującej projekt na jego podstawie jest zaprojektowanie
 i wykonanie całego zestawu urządzeń peryferyjnych.
\end_layout

\begin_layout Standard
W przypadku tego projektu niezbędne będą urządzenia do komunikacji z użytkowniki
em, ponieważ to on decyduje o momencie załączenia pompy oraz będzie miał
 możliwość śledzenia temperatury cieczy.
 Cały układ poza odebraniem danych od użytkownika musi być w stanie zmierzyć
 temperaturę cieczy
\begin_inset CommandInset citation
LatexCommand cite
key "elektrotechniDlaNielektro"

\end_inset

 wewnątrz pojemnika z komputerem.
 Jak wiadomo płyta główna jest sporym podzespołem więc rozmiary pojemnika,
 w którym zanurzony będzie komputer będą znaczące dla odczytu temperatury.
 Zastosowano więc dwa czujniki temperatury, które odczytywać będą temperaturę
 z dwóch różnych miejsc w pojemniku.
 Ciecz znajdująca się wewnątrz pojemnika musi mieć gdzie oddać ciepło przejęte
 z podzespołów.
 W tym celu zastosowano pompę, która przetłoczy ciecz przez zewnętrzną chłodnicę.
 Pracując przy komputerze użytkownicy często skupiają się tylko na swoim
 zadaniu.
 By system był efektywny zastosowano właśnie automatyczne sterowanie załączeniem
 pompy, wykorzystujące Arduino.
\end_layout

\begin_layout Subsection
Projekt układu elektronicznego
\end_layout

\begin_layout Standard
Komunikacja z mikrokontrolerem jest istotnym elementem tego projektu.
 Arduino ma generować dane: aktualną średnią temperaturę cieczy, oraz temperatur
ę po przekroczeniu której załączona zostanie pompa, które będą wyświetlane.
 Temperatura załączenia pompy ustawiana jest przez użytkownika.
 Tak więc do komunikacji niezbędny będzie wyświetlacz.
 Do tego typu danych wybrany został wyświetlacz LCD posiadający dwa rzędy
 znaków po 16 znaków w każdym.
 Do ustawiania temperatury wykorzystane zostały dwa przyciski monostabilne,
 których zwarcie monitorowane będzie przez mikrokontroler.
\end_layout

\begin_layout Standard
Układ elektroniczny systemu chłodzącego musi również być w stanie mierzyć
 temperaturę cieczy.
 Do tego zadania wybrane zostały dwa czujniki LM35, które cechują się szerokim
 zakresem pomiaru (od -50°C do +150°C), w którym mieści się zakres odczytywanych
 temperatur.
 Ciecz minimalnie będzie osiągała temperaturę pokojową, a maksymalnie nie
 przekroczy 100°C.
\end_layout

\begin_layout Standard
Nagrzaną przez podzespoły cieczy należy wychłodzić poza zbiornikiem z komputerem.
 Aby przetłoczyć ciecz poza pojemnik wykorzystano pompkę elektryczną, której
 wymagane zasilanie znacznie przewyższa możliwości Arduino.
 Wykorzystano więc przekaźnik, który wysterowany przez Arduino załączy pompkę
 w odpowiednim momencie.
\end_layout

\begin_layout Standard
Podsumowując, nasz układ elektroniczny składać się będzie z:
\end_layout

\begin_layout Itemize
płytki Arduino UNO rev.
 3,
\end_layout

\begin_layout Itemize
wyświetlacza LCD 2 razy po 16 znaków JHD162A-B-W,
\end_layout

\begin_layout Itemize
dwóch przycisków monostablinych,
\end_layout

\begin_layout Itemize
dwóch czujników temperatury LM35,
\end_layout

\begin_layout Itemize
przekaźnika,
\end_layout

\begin_layout Itemize
pompki,
\end_layout

\begin_layout Itemize
zewnętrznego źródła zasilania.
\end_layout

\begin_layout Standard
Połączenia między wszystkimi podzespołami zostały zaprojektowane zgodnie
 z notami katalogowymi poszczególnych podzespołów.
 Połączenia między poszczególnymi elementami przestawione zostały na schemacie
 poglądowym (Rysunek 3.6).
 Tworzenie takich schematów ma na celu łatwe odczytanie projektu
\begin_inset CommandInset citation
LatexCommand cite
key "inteligentnyDom"

\end_inset

 przez innych twórców.
 Na tym schemacie urządzenia przedstawione zostały za pomocą grafik przybliżając
y faktyczny wygląd poszczególnych elementów (nie zostały zachowane proporcje
 ze względu na zróżnicowany rozmiary elementów układu), oraz przedstawione
 wszystkie niezbędne fizyczne połączenia.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename schematPogladowy.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat poglądowy wykonany we Fritzing
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
W celu stworzenia odpowiedniej dokumentacji projektu, układ elektryczny
 został zaprezentowany na funkcjonalnym schemacie elektrycznym
\begin_inset CommandInset citation
LatexCommand cite
key "praktycznaOgolna"

\end_inset

 (Rysunek 3.7).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename schematElektryczny.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat elektryczny układu współpracującego z Arduino wykonany w EAGLE
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wykonanie układu elektronicznego
\end_layout

\begin_layout Standard
Wykonanie układu elektronicznego rozpoczęto od wykonania modułu odpowiedzialnego
 za komunikację z użytkownikiem.
 Elementy zamontowane na płytce stykowej projektu (Rysunek 3.6) zostały zlutowane
 zgodnie z zasadami lutowania miękkiego
\begin_inset CommandInset citation
LatexCommand cite
key "praktycznaOgolna"

\end_inset

 na płytce prototypowej.
 Montaż części odpowiedzialnych za komunikację na jednej płytce umożliwił
 wyprowadzenie tego modułu na długich przewodach i umieszczenie ich w widocznym
 miejscu obudowy (na przedniej ścianie akwarium).
 Przewody zakończone zostały goldpinami w celu umożliwienia podpięcia ich
 do płytki Arduino (Rysunek 3.8).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/WP_20151202_15_22_13_Pro.jpg
	lyxscale 50
	width 80text%
	groupId fotografie

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Zmontowany moduł komunikacji
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Czujniki temperatury również zostały przylutowane do długich przewodów by
 można było umieścić je w odpowiednich miejscach w obudowie.
 Jeden tuż przy radiatorze procesora, drugi w pobliżu radiatora karty graficznej.
 Zasilacz, pompa i przekaźnik są elementami gotowymi.
 Wystarczyło tylko wykonać odpowiednie połączenia do płytki Arduino, zgodnie
 z połączeniami przestawionymi na schemacie (Rysunek 3.7).
 Kolejno podłączono:
\end_layout

\begin_layout Itemize
dwa czujniki temperatury LM35: piny GND czujników wpięto do wspólnej masy
 całego układu, piny VCC czujników wpięto do zasilania 5V wyprowadzonego
 z płytki Arduino, piny SIGNAL czujników wpięto do analogowych wejść płytki
 Arduino A0 i A1,
\end_layout

\begin_layout Itemize
wyświetlacz JHD162A-B-W: piny VSS, R/W, C wyświetlacza podpięto do wspólnej
 masy całego układu, piny VDD i A wyświetlacza wpięto do zasilania 5V wyprowadzo
nego z płytki Arduino, piny RS, E, D4, D5, D6, D7 zostały podpięte do kolejnych
 cyfrowych wejść/wyjść płytki Arduino 12, 11, 10, 8, 7, 6,
\end_layout

\begin_layout Itemize
przyciski monostabilne: pin 1 przycisków monostabilnych zostały wpięte do
 cyfrowych wejść/wyjść płytki Arduino 3 i 2, pin 3 obu przycisków podpięto
 do wspólnej masy układu,
\end_layout

\begin_layout Itemize
przekaźnik: pin VCC przekaźnika wpięto do zasilania 5V wyprowadzonego z
 płytki Arduino, pin GND przekaźnika podpięto do wspólnej masy układu, pin
 SIGNAL_IN podłączono do 4 cyfrowego wejścia/wyjścia płytki Arduino, linia
 zasilania pompy podpięta została podłączona do zacisku NO (ang.
 normally open) przekaźnika, linia uziemienia pompy połączona została z
 uziemieniem źródła zasilania pompy natomiast napięcie źródła zasilania
 pompy wpięto do zacisku C przekaźnika.
\end_layout

\begin_layout Standard
Po wykananiu odpowiednich połączeń (Rysunek 3.9) należało zaimplementować
 pracę podłączonych elementów układu w oprogramowaniu Arduino.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/WP_20160104_14_41_22_Pro.jpg
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Podłączony układ elektryczny współpracujący z Arduino
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementacja sterownika układu chłodzącego na platformie Arduino
\end_layout

\begin_layout Subsection
Opis algorytmu głównego
\end_layout

\begin_layout Standard
Algorytm główny sterownika ma kilka zadań.
 Jednym z nich jest stałe monitorowanie odczytu czujników temperatury i
 na podstawie tych odczytów, obliczanie i wyświetlanie temperatury cieczy
 na ekranie.
 Pomiar temperatury chłodziwa znajdującego się w obudowie jest również wyznaczni
kiem momentu załączenia pompy.
 Gdy temperatura parafiny w obudowie przekroczy ustawioną przez użytkownika
 temperaturę krytyczną, Arduino ma za zadanie załączenie pompy, która przetłoczy
 ciecz przez chłodnicę.
 Gdy temperatura chłodziwa spadnie poniżej poziomu krytycznego, Arduino
 wyłączy pompę.
 Poziom krytyczny, o którym mowa ustawiany jest przez użytkownika przy pomocy
 przycisków monostabilnych.
 Nasłuchiwanie wspomnianych przycisków to również jedno z zadań sterownika.
 Praca sterownika przedstawiona została na diagramie przepływu (Rysunek
 3.10).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/diagramSterownika.png
	lyxscale 50
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagram przepływu pracy sterownika
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementacja algorytmu głównego
\end_layout

\begin_layout Standard
Programy wykonywane przez Arduino pisane są w specjalnym języku Arduino,
 który bazuje na językach C/C++ oraz środowisku Wiring.
 Kod programu Arduino składa się głównie z 3 bloków
\begin_inset CommandInset citation
LatexCommand cite
key "inteligentnyDom"

\end_inset

:
\end_layout

\begin_layout Itemize
część odpowiedzialna za inicjalizację urządzenia - deklaracja zmiennych
 globalnych, stałych, definicji funkcji, dodanie bibliotek,
\end_layout

\begin_layout Itemize
funkcji setup - funkcja wykonywana raz po uruchomieniu urządzenia,
\end_layout

\begin_layout Itemize
funkcji loop - funkcja wykonywana nieprzerwanie przez urządzenie.
\end_layout

\begin_layout Standard
Poniżej przedstawiono kod sterownika podzielony na wyżej wymienione bloki.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Inicjalizacja urządzenia Arduino
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\sffamily}"
inline false
status open

\begin_layout Plain Layout

#include <LiquidCrystal.h>
\end_layout

\begin_layout Plain Layout

LiquidCrystal lcd(12, 11, 10, 8, 7, 6);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define relay 4
\end_layout

\begin_layout Plain Layout

#define buttonUp 3
\end_layout

\begin_layout Plain Layout

#define buttonDown 2
\end_layout

\begin_layout Plain Layout

#define lm35_1_pin 0
\end_layout

\begin_layout Plain Layout

#define lm35_2_pin 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int tempCritical = 55;
\end_layout

\begin_layout Plain Layout

int tempAvg;
\end_layout

\begin_layout Plain Layout

float tempLm35_1;
\end_layout

\begin_layout Plain Layout

float tempLm35_2;
\end_layout

\begin_layout Plain Layout

int lm35_1;
\end_layout

\begin_layout Plain Layout

int lm35_2;
\end_layout

\begin_layout Plain Layout

bool pump = false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool increaseTemp() {
\end_layout

\begin_layout Plain Layout

  int zwiekszenie = !digitalRead(buttonUp);
\end_layout

\begin_layout Plain Layout

  return zwiekszenie;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bool decreaseTemp() {
\end_layout

\begin_layout Plain Layout

  int zmniejszenie = !digitalRead(buttonDown);
\end_layout

\begin_layout Plain Layout

  return zmniejszenie;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Przedstawiony listing Algorytm 1 odpowiada za inicjalizację urządzenia.
 Jest on wykonywany tylko raz, zaraz po włączeniu urządzenia.
 Linie 1 i 2 odpowiadają za dodanie biblioteki obsługującej wyświetlacz
 LCD oraz jego inicjalizację na wyjściach płytki Arduino o numerach 12,
 11, 10, 8, 7, 6.
 Linie od 4 do 8 są definicją pinów urządzeń podpiętych do płytki.
 Kolejno są to:
\end_layout

\begin_layout Itemize
przerzutnik na pinie 4,
\end_layout

\begin_layout Itemize
przycisk monostabilny odpowiedzialny za zwiększanie temperatury krytycznej
 na pinie 3,
\end_layout

\begin_layout Itemize
przycisk monostabilny odpowiedzialny za zmniejszanie temperatury krytycznej
 na pinie 2,
\end_layout

\begin_layout Itemize
dwa czujniki temperatury LM35 na pinach 0 i 1.
\end_layout

\begin_layout Standard
Następnie zdefiniowano zmienne, w liniach od 10 do 16:
\end_layout

\begin_layout Itemize
temperatura krytyczna,
\end_layout

\begin_layout Itemize
temperatura średnia,
\end_layout

\begin_layout Itemize
obliczona temperatura dla obu czujników,
\end_layout

\begin_layout Itemize
odczyt wartości z obu czujników,
\end_layout

\begin_layout Itemize
stan załączenia pompy.
\end_layout

\begin_layout Standard
Linie od 18 do 26 zawierają bliźniacze funkcje.
 Funkcje te odpowiadają za wykrywanie przyciśnięcia przycisków odpowiadających
 za ustawianie temperatury krytycznej.
 Wykorzystano w nich funkcję dostępną w języku Arduino, digitalRead().
 Funkcja ta zwraca stany HIGH lub LOW w zależności od tego jaki stan znajduje
 się na pinie, którego numer podajemy jako parametr.
 Stany HIGH i LOW równoważne są z wartościami zmiennych logicznych true
 i false oraz 1 i 0.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Funkcja setup()
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\sffamily}"
inline false
status open

\begin_layout Plain Layout

void setup() {
\end_layout

\begin_layout Plain Layout

  lcd.begin(16, 2);
\end_layout

\begin_layout Plain Layout

  pinMode(buttonUp, INPUT_PULLUP);
\end_layout

\begin_layout Plain Layout

  pinMode(buttonDown, INPUT_PULLUP);
\end_layout

\begin_layout Plain Layout

  pinMode(relay, OUTPUT);
\end_layout

\begin_layout Plain Layout

  digitalWrite(relay, HIGH);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zaprezentowany listing Algorytm 2 to funkcja setup().
 Jest to funkcja, którą urządzenie wykona tylko raz zaraz po uruchomieniu.
 W jej wnętrzu można ustawić wartości zmiennych, ustawić rolę poszczególnych
 pinów płytki Arduino czy wywoływać funkcje dostępne w bibliotekach, które
 wcześniej dodano do sketch'u.
\end_layout

\begin_layout Standard
W linii 2, wywołana została funkcja z biblioteki obsługującej wyświetlacz
 ciekłokrystaliczny.
 W jej parametrach podano kolejno ilość znaków w wierszu, w tym przypadku
 16 oraz ilość wierszy czyli 2.
 Linie 3 i 4 odpowiadają za ustawienie funkcji pinów, do których podłączone
 zostały przyciski monostabilne za pomocą, których ustawiana jest temperatura
 krytyczna.
 Jako parametry funkcji ustawiającej piny pinMode() podano kolejno numer
 pinu, w tym przypadku wykorzystano stałą, która została zadeklarowana w
 tym celu i tryb w jakim pracować ma zadany pin, w tym przypadku INPUT_PULLUP,
 który wykorzystuje wbudowane w mikrokontroler rezystory podciągające i
 działa jako wejście odporne na skoki napięcia, co zapobiega występowaniu
 zakłóceń związanych z pracą pinu wejściowego.
 Linia 5 to ustawienie pinu, do którego podłączony jest przekaźnik jako
 pin wyjścia, dzięki czemu w części głównej algorytmu można ustawić żądany
 stan na zadanym pinie.
 Linia 6 jest ustawieniem pinu, do którego podłączony jest przekaźnik na
 stan wysoki, co skutkuje wyłączeniem pompy.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Funkcja loop()
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\sffamily}"
inline false
status open

\begin_layout Plain Layout

void loop() {   
\end_layout

\begin_layout Plain Layout

  lm35_1 = analogRead(lm35_1_pin);
\end_layout

\begin_layout Plain Layout

  lm35_2 = analogRead(lm35_2_pin);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  tempLm35_1 =lm35_1 * 0.48828125;
\end_layout

\begin_layout Plain Layout

  tempLm35_2 =lm35_2 * 0.48828125;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  tempAvg = (tempLm35_1 + tempLm35_2)/2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if (tempCritical < tempAvg && !pump) {
\end_layout

\begin_layout Plain Layout

    digitalWrite(relay, LOW);
\end_layout

\begin_layout Plain Layout

    pump = true;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if (tempCritical > tempAvg && pump) {
\end_layout

\begin_layout Plain Layout

    digitalWrite(relay, HIGH);
\end_layout

\begin_layout Plain Layout

    pump = false;
\end_layout

\begin_layout Plain Layout

  }      
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  if (decreaseTemp())
\end_layout

\begin_layout Plain Layout

    tempCritical--;
\end_layout

\begin_layout Plain Layout

  if (increaseTemp())
\end_layout

\begin_layout Plain Layout

    tempCritical++;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  lcd.clear();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  lcd.setCursor(0, 0);
\end_layout

\begin_layout Plain Layout

  lcd.print("Temp ciecz ");
\end_layout

\begin_layout Plain Layout

  lcd.print(tempAvg);
\end_layout

\begin_layout Plain Layout

  lcd.print((char)223);
\end_layout

\begin_layout Plain Layout

  lcd.print("C");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  lcd.setCursor(0, 1);
\end_layout

\begin_layout Plain Layout

  lcd.print("Temp kryty ");
\end_layout

\begin_layout Plain Layout

  lcd.print(tempCritical);
\end_layout

\begin_layout Plain Layout

  lcd.print((char)223);
\end_layout

\begin_layout Plain Layout

  lcd.print("C");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  delay(200);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Funkcja loop przedstawiona na listingu Algorytm 3, wykonywana jest przez
 cały czas załączenia urządzenia, w niej realizowane są zadania, które wykonać
 ma mikrokontroler.
 Linie 2 i 3 odpowiadają za odczytanie wartości przetwornika analogowo-cyfrowego
 na pinach, do których podpięte są czujniki temperatury.Do tego celu wykorzystano
 funkcje analogRead(), której parametrami są numery pinów, z których odczyt
 ma być wykonany.
 Mikrokontroler wbudowany w Arduino posiada 10 bitowy przetwornik analogowo-cyfr
owy, czyli odczyt będzie z zakresu od 0 do 1023.
 Linie 5 i 6 mają za zadanie przetworzenie odczytanej wartości na liczbę
 reprezentującą ilość stopni Celsjusza.
 Liczba 0,48828125 została wyliczona ze wzoru:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
T & =\frac{ADC*\frac{AREF}{1024}}{10mV}\label{eq:}
\end{align}

\end_inset

gdzie:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
T liczba reprezentująca temperaturę w stopniach Celsjusza,
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ADC odczyt z przetwornika analogowo-cyfrowego,
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
AREF napięcie odniesienia używane przez przetwornik analogowo-cyfrowy, wtym
 przypadku 5V = 5000mV,
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
1024 zakres odczytu przetwornika analogowo-cyfrowego,
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
10mV ilość mV, która równoważna jest 1°C.
\end_layout

\begin_layout Standard
Linia 8 to wyliczenie średniej temperatury cieczy znajdującej się w pojemniku
 z komputerem.
 W liniach od 10 do 13 zamieszczono instrukcję warunkową odpowiedzialną
 za załączenie pompy.
 Warunek w tej instrukcji jest prawdziwy, gdy średnia temperatura cieczy
 jest większa od ustawionej temperatury krytycznej i gdy pompa nie jest
 załączona.
 Spełnienie warunku powoduje ustawienie stanu niskiego na pinie, do którego
 podpięty jest przekaźnik i ustawienie zmiennej przetrzymującej stan załączenia
 na prawdę.
 Linie od 15 do 18 zawierają analogiczną instrunkcję warunkową, z tym że
 tutaj wykrywany jest moment wyłączenia.
 Warunek jest prawdziwy gdy średnia temperatura cieczy jest niższa niż temperatu
ra krytyczna i pompa jest załączona.
 Spełnienie warunku powoduje ustawienie stanu wysokiego na pinie, do którego
 podpięty jest przekaźnik i ustawienie zmiennej przetrzymującej stan załączenia
 pompy na fałsz.
\end_layout

\begin_layout Standard
Linie od 20 do 23 odpowiadają za wykrycie zwarcia przycisków monostabilnych.
 Wykorzystano tu funkcje decreaseTemp() oraz increaseTemp(), które opisano
 przy opisie listingu Algorytm 1.
 Wykrycie zwarcia odpowiedniego przycisku skutkuje zwiększeniem lub zmniejszenie
m temperatury krytycznej.
\end_layout

\begin_layout Standard
Linie od 25 do 37 odpowiadają za wyświetlanie informacji na wyświetlaczu.
 W tej części kodu wykorzystano kilka funkcji dostępnych w bibliotece LiquidCrys
tal.h.
 Funkcję clear(), która czyści zawartość wyświetlacza.
 Funkcję setCursor(), która przyjmuje w parametrach pozycję kursora i ustawia
 go w niej.
 Pierwsza liczba to numer znaku w wierszu, druga jest numerem wiersza.
 Funkcję print(), która jako parametr przyjmuje tablicę znaków, które mają
 być wyświetlone.
 Tablica może być wyrażeniem zawartym w cudzysłów, zmienną, lub kodem znaku
 odczytanym z dokumentacji technicznej prze konwertowanym na znak.
\end_layout

\begin_layout Standard
Ostatnia linia kodu to instrukcja delay(), która za parametr przyjmuje ilość
 milisekund przez które ma wstrzymać wykonywanie kodu.
 W tym przypadku podano 200.
 Oznacza to iż cały kod wykona się 5 razy w ciągu sekundy.
 Zapewnia to odpowiednio częsty pomiar temperatury by zauważyć jej zmiany,
 jednocześnie nie zakłócając obrazu wyświetlanego na wyświetlaczu.
\end_layout

\begin_layout Chapter
Testy wydajnościowe i analiza wyników
\end_layout

\begin_layout Section
Testy wydajnościowe chłodzenia podzespołów 
\end_layout

\begin_layout Standard
Określenie skuteczności zbudowanego systemu chłodzącego wymagało przeprowadzenia
 serii eksperymentów.
 Zostały one przedstawione w poniższym rozdziale.
 Zaprezentowano również konfigurację testowanego komputera oraz opisano
 jego standardowy system chłodzenia.
\end_layout

\begin_layout Subsection
Opis testowanego sprzętu
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="middle" width="10cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Podzespół
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zainstalowany sprzęt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Płyta główna
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gigabyte® GA-EP35-DS3
\end_layout

\begin_layout Plain Layout
Mostek północny: Chipset Intel® P35 Express
\end_layout

\begin_layout Plain Layout
Mostek południowy: Intel® ICH9
\end_layout

\begin_layout Plain Layout
FSB: 1600 (O.C.)/1333/1066/800 MHz
\end_layout

\begin_layout Plain Layout
Złącza PCI: 1 x PCI Express x16, 3 x PCI Express x1
\end_layout

\begin_layout Plain Layout
RAM: DDR2 1200(O.C.)/1066/800/667 MHz
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Procesor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intel® Core™ 2 Quad Q9300
\end_layout

\begin_layout Plain Layout
Rdzenie: 4 x 2.50 GHz
\end_layout

\begin_layout Plain Layout
FSB: 1333 MHz
\end_layout

\begin_layout Plain Layout
Zestaw instrukcji: 64
\end_layout

\begin_layout Plain Layout
Litrografia 45 nm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Karta graficzna
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gigabyte® GV-N98TSL-1GI
\end_layout

\begin_layout Plain Layout
Chipset: GeForce 9800 GT
\end_layout

\begin_layout Plain Layout
Pamięć: GDDR3 1 GB
\end_layout

\begin_layout Plain Layout
Magistrala pamięci: 256 bitwów
\end_layout

\begin_layout Plain Layout
Magistrala karty graficznej: PCI-E 2.0
\end_layout

\begin_layout Plain Layout
Wsparcie DirectX: 10
\end_layout

\begin_layout Plain Layout
Wsparcie OpenGL: 2.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pamięć RAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GEIL PC2-6400 800Mhz
\end_layout

\begin_layout Plain Layout
Rodzaj pamięci: DDR2
\end_layout

\begin_layout Plain Layout
Pojemność pamięci: 4 GB (2x2GB)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dysk twardy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Western Digital WD5000AZRX
\end_layout

\begin_layout Plain Layout
Pojemnośc: 500 GB
\end_layout

\begin_layout Plain Layout
Pamięć cache: 64 MB
\end_layout

\begin_layout Plain Layout
Prędkość obrotowa: 7200 obr./min.
\end_layout

\begin_layout Plain Layout
Interfejs: Serial ATA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zasilacz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MODECOM FEEL 1 500ATX
\end_layout

\begin_layout Plain Layout
Moc: 500 W
\end_layout

\begin_layout Plain Layout
Standard: ATX 2.2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykaz podzespołów testowanego komputera
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Komputer, którego podzespoły zostały użyte w projekcie (Tablica 4.1) chłodzony
 był w sposób standardowy.
 Procesor chłodzony był przez wentylowany, aluminiowy radiator w kształcie
 walca średnicy około 10 cm i wysokości około 1 cm, dostarczony wraz z procesore
m przez jego producenta.
 Karta graficzna znajdująca się w komputerze, posiadała chłodzenie pasywne.
 Masywny radiator wykonany z aluminium oraz wyposażony w miedziane rurki
 cieplne (ang.
 heat pipe) odprowadzał ciepło bez użycia żadnych wentylatorów.
 Całość zamknięta była w metalowej obudowie wentylowanej jednym wentylatorem.
\end_layout

\begin_layout Subsection
Opis eksperymentu
\end_layout

\begin_layout Standard
Podczas przeprowadzania eksperymentu sprawdzającego wydajność zbudowanego
 układu wykorzystano oprogramowanie OCCT.
 Wykonano szereg testów z wykorzystaniem biblioteki LINPACK zmodernizowanej
 przez Intel®.
 Testy benchmark oparte na tej bibliotece mają za zadanie rozwiązać gęsty
 układ równań liniowych.
\end_layout

\begin_layout Standard
Układ chłodzący zrealizowany w tym projekcie ma możliwość ustawienia temperatury
 załączenia pompy.
 W związku z tym przeprowadzono po trzy próby testów dla kolejnych ustawień
 temperatury krytycznej: 45°C, 50°C, 55°C.
 Każda z przeprowadzonych prób trwała 30 minut oraz rozpoczynała się gdy
 temperatura cieczy znajdującej się w akwarium nie przekraczała 30°C.
\end_layout

\begin_layout Standard
Temperatura poszczególnych rdzeni procesora rejestrowana była co 30 sekund.
 Na podstawie zebranych danych wykonano wykresy przedstawiające wyniki eksperyme
ntu.
\end_layout

\begin_layout Section
Analiza wyników 
\end_layout

\begin_layout Standard
Punktem odniesienia dla przeprowadzanego eksperymentu była wydajność chłodzenia
 standardowego.
 W tyn celu przeprowadzono test przy użyciu programu OCCT.
 Załączono test trwający godzinę, który maksymalnie obciążał procesor.
 Wyniki testu przedstawione zostały na wykresach (Rysunek 4.1, Rysunek 4.2,
 Rysunek 4.3, Rysunek 4.4).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename D:/testy/TestWCIECZNAZERO/2016-01-15-14h56-Temperature-Core #0.png
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres temperatur rdzenia 0 wykonany w OCCT
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename D:/testy/TestWCIECZNAZERO/2016-01-15-14h56-Temperature-Core #0.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres temperatur rdzenia 1 wykonany w OCCT
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename D:/testy/TestWCIECZNAZERO/2016-01-15-14h56-Temperature-Core #2.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres temperatur rdzenia 2 wykonany w OCCT
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename D:/testy/TestWCIECZNAZERO/2016-01-15-14h56-Temperature-Core #3.png
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres temperatur rdzenia 3 wykonany w OCCT
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podczas testu standardowego chłodzenia zaraz po obciążeniu procesora temperatura
 na wszystkich czterech rdzeniach momentalnie wzrasta i oscyluje w okolicach
 poziomu 88°C.
 Widoczne na wykresie kilkustopniowe chwilowe wzrosty temperatury spowodowane
 są sterowaniem wentylatora przez system.
 Pomimo tych chwilowych wzrostów temperatury zauważyć można tendencję wzrostową
 średniej temperatury.
 Na początku obciążenia procesora temperatura waha się w okolicach 88°C,
 natomiast po upływie około godziny testu temperatura wzrosła do okolic
 98°C, a nawet momentami zbliżała się do 100°C co jest niebezpieczne dla
 procesora.
\end_layout

\begin_layout Standard
Po przeprowadzeniu testów zbudowanego układu chłodzącego wyniki zaprezentowano
 na wykresach.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/sredniardzeni-45.PNG
	lyxscale 90
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres temperatur poszczególnych rdzeni dla temperatury krytycznej 45°C
 wykonany w Excel 2013
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/sredniardzeni-50.PNG
	lyxscale 90
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres temperatur poszczególnych rdzeni dla temperatury krytycznej 50°C
 wykonany w Excel 2013 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/sredniardzeni-55.PNG
	lyxscale 90
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres temperatur poszczególnych rdzeni dla temperatury krytycznej 55°C
 wykonany w Excel 2013
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Temperatura na wszystkich wykresach oscyluje głównie w granicach 70°C -
 80°C.
 Na pierwszym wykresie (Rysunek 4.1) w okolicach 12 minut trwania testu zauważyć
 można spadek temperatury na wszystkich czterech rdzeniach.
 Jest to moment załączenia pompy.
 Podobny spadek temperatury widać na schemacie (Rysunek 4.2) odpowiadającym
 za reprezentowanie wyników dla temperatury krytycznej ustawionej na 50°C.
 W tym przypadku pompa jednak załączyła się jednak około 10 minut później,
 w okolicach 24 minuty trwania testu.
 Podczas trwania testów dla temperatury załączenia pompy ustawionej na 55°C
 nie zauważono załączenia pompy, co widać na wykresie (Rysunek 4.3).
\end_layout

\begin_layout Standard
Kolejny wykres (Rysunek 4.4) przedstawia średnią temperaturę wszystkich rdzeni
 zaobserwowaną dla poszczególnych ustawień temperatury krytycznej.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename zdjęcia/średnia.PNG
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wykres średniej temperatury rdzeni dla różnych temperatur krytycznych wykonany
 w Excel 2013
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Różnica pomiędzy średnia temperaturą dla 45°C wynoszącą 75,6°C a 50°C, której
 wartość wynosi około 75,3 jest niewielka (jedynie 0,3°C) i mieści się w
 zaznaczonym błędzie.
 Niższy poziom średniej temperatury dla 50°C jest wynikiem błędu w pomiarze
 oraz zaokrąglenia nanoszonego przez komputer.
 Tak niewielką różnice można pominąć i traktować wyniki jako zbliżone do
 siebie.
 Dopiero średnia temperatura dla temperatury krytycznej ustawionej na poziomie
 55°C, jest wyższa niż temperatury w dwóch pozostałych przypadkach.
 Wynosi ona 76,7°C.
 Wywołane jest to brakiem załączenia pompy, ustawienie to nie załączyło
 pompy w czasie 30 minut trwania testu.
\end_layout

\begin_layout Standard
Zastosowanie zbudowanego systemu chłodzącego zaowocowało spadkiem średniej
 temperatury rdzeni procesora o około 15°C.
 Po modernizacji systemu chłodzenia temperatura rdzeni procesora, nie zbliżyła
 się ani razu do niebezpiecznego poziomu 100°C, co więcej ledwo przekroczyła
 80°C.
 Porównując to do wyników sprzed modernizacji jest dobrym wynikiem, który
 dowodzi skuteczności zastosowanego systemu.
\end_layout

\begin_layout Chapter
Podsumowanie
\end_layout

\begin_layout Standard
Celem powyższej pracy dyplomowej było zaprojektowanie i zbudowanie automatyczneg
o systemu chłodzącego.
 Rolę sterownika w projekcie przyjęła platforma Arduino.
 Wykorzystana platforma spełniła swoje zadanie i wykonuje wszystkie funkcje
 przewidziane dla niej w projekcie algorytmu głównego.
 Analiza wyników testu dowiodła iż zbudowany automatyczny system chłodzenia
 spełnia swoją rolę.
 Temperatura rdzeni procesora zmniejszyła się o około 15°C co jest dobrym
 wynikiem.
 Pomimo maksymalnego obciążenia procesora, temperatura na jego rdzeniach
 nie zbliżyła się do niebezpiecznego poziomu 100°C.
 Zapewnia to bezpieczne korzystanie z komputera nawet przy bardzo wymagających
 zadaniach.
\end_layout

\begin_layout Standard
Niezbędne okazało się przetłaczanie cieczy przez chłodnicę.
 Chłodziwo bez obiegu chłodzącego odbierało ciepło z podzespołów, lecz nie
 miało jak oddać go do otoczenia.
 Pomimo zauważalnej skuteczności systemu stwierdzono, iż zastosowanie wentylator
a chłodzącego chłodnicę, zwiększyłoby skuteczność zastosowanego systemu
 chłodzącego.
 Jak wiadomo skuteczność zbudowanego układu chłodzącego zależy w dużej mierze
 od chłodzenia cieczy poza zbiornikiem z podzespołami komputera.
 W projekcie nie przewidziano funkcji wskazywania przepływu cieczy.
 Funkcja ta mogłaby być wskaźnikiem wystąpienia nieszczelności w układzie
 obiegu chłodzącego, lub uszkodzenia pompy.
\end_layout

\begin_layout Standard
Wybór cieczy zastosowanej jako chłodziwo stawiał na bezpieczeństwo.
 Głównym czynnikiem była przewodność prądu, a właściwie jej brak oraz dostępność
 na rynku.
 Rozwijając projekt można by zastanowić się nad właściwościami termicznymi
 różnych cieczy.
 Przeprowadzenie szeregu badań z zastosowaniem różnych cieczy mogłoby zwiększyć
 skuteczność zbudowanego systemu oraz pokazać jego skuteczność podczas dłuższego
 obciążenia.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "C:/Users/Michał/Desktop/bilbigrafia"
options "ieeetr"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\end_body
\end_document
